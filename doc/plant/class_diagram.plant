
@startuml
'The namespace should be Kf::
set namespaceSeparator ::

'Main Facade Class
class Kampf << (S,#FF7700) Facade >> {
   - AbstractRenderWindow windowContext
   - std::vector<AbstractSystem> systemList
   - std::vector<AbstractManager> managerList
   - Messenger messenger
   ==
   .. constructor ..
   + void Kampf()
   + void runMainLoop(bContinuous=true)
   -- getters --
   + AbstractSystem getSystem(enum SystemType enumSystem)
   + AbstractManager getManager(enum ManagerType enumManager)
   + Messenger getMessenger()
}

'The main render window, where all of the magic happens
abstract class AbstractRenderWindow {
   - int windowWidth = 800
   - int windowHeight = 600
   ==
   + draw(AbstractDrawable drawable)
} 

''
'' ENTITIES
''
package "Entities" #C3B1A3 {
abstract class AbstractEntity {
   - static incrementType EntityID = 0
   - long id
   - std::vector<AbstractComponent> components
   - string name = ""
   - string type = "abstract"
   ==
   .. constructor ..
   + AbstractEntity(std::string name, long id)
   -- getters/setters --
   .. id ..
   + long getID()
   + void setID(long id)
   .. components ..
   + std::list<AbstractComponent> getComponentsByFamily(enum ComponentFamily family)
   + std::list<AbstarctComponent> getComponentByName(std::string name)
   + void addComponent(AbstractComponent theComponent)
   + AbstractComponent::iterator traverseComponentTree()
   .. name ..
   + std::string getName()
   + setName(std::string name)
   .. type .. 
   + string getType()
} 	

} 
'END package "Entities"

''Relation between Entities
'' Nothing here


''
'' MANAGERS
''

package "Managers" #FE6F4D {
abstract AbstractManager {
   - enum ManagerType enumManagerType
}

enum ManagerType {
	 ENTITY
	 VOID
}


class EntityManager {
   - std::vector<AbstractEntity> entityList
   ==
   + void addEntity(AbstractEntity entity)
   + std::vector<AbstractEntity> getAllEntities()
   + AbstractEntity getEntityByID()
   + 
} 

} 
'END package "Managers"

''Manager Relations
AbstractManager -- ManagerType
EntityManager -|> AbstractManager


''
'' CustomAttribute
''

package "CustomAttribute" {

class CustomAttributeValue {
   - enum AttributeType enumAttributeType
   - CustomAttributeUnion value
   ==
   + void setValue(long long ll)
   + auto getValue(long long ll)
   + void setValue(int i)
   + auto getValue(int i)
   + void setValue(double d)
   + auto getValue(double d)
   + void setValue(float f)
   + auto getValue(float f)
   + void setValue(char c)
   + auto getValue(char c)
}

class CustomAttributePtr {
   - enum AttributePointerType enumAttributePointerType
   - void* valuePtr
   ==
   + auto getPtr()
   + void* getVoidPtr()
}

enum AttributePointerType {
	 VOID
	 INTEGER_VECTOR
	 DOUBLE_VECTOR
	 STRING
}

enum AttributeType {
	 LONGLONG
	 INTEGER
	 DOUBLE
	 FLOAT
	 CHAR
}

class CustomAttributeUnion << (U, #FFFFFF) Union >> {
   + long long ll
   + int i
   + double d
   + float f
   + char c
}

} 
'END package "CustomAttribute"

'CustomAttribute Relations
CustomAttributeValue o-- CustomAttributeUnion : one >
CustomAttributeValue -- AttributeType
CustomAttributePtr o- AttributePointerType : one >

''
'' COMPONENTS
''

package "Components" #95ABD4 {

abstract class AbstractComponent {
   - static incrementType CustomValueID = 0
   - static incrementType CustomPtrID = 0
   - std::string name
   - enum ComponentFamily family
   - bool bIsParent = false
   - std::map<incrementType, CustomAttributeValue> customValueMap
   - std::map<incrementType, CustomAttributePtr> customPtrMap
   - std::list<AbstractComponent> children = nullptr
   ==
   .. constructor ..
   + AbstractComponent(std::string name, enum ComponentFamily family, bool isParent)
   .. name ..
   + std::string getName()
   + void setName(std::string name)
   .. family ..
   + enum ComponentFamily getFamily()
   + void setFamily(enum ComponentFamily family)
   .. bIsParent ..
   + bool isParent()
   .. custom values ..
   + incrementType setCustomAttributeValue(auto)
   + incrementType setCustomAttributePtr(auto, enumAttributePointerType = VOID)
   + CustomAttributeValue getCustomAttributeValue(incrementType)
   + CustomAttributePtr getCustomAttributePtr(incrementType)
   .. children ..
   void addChild(AbstractComponent)
}

class PositionComponent {

}

class SpriteComponent {

}

class CollisionComponent {

}

class TextComponent {

}

class PhysicsComponent {

}

'Aggregation between the component and the CustomAttributes
AbstractComponent o-- CustomAttributeValue
AbstractComponent o-- CustomAttributePtr



} 
'END package "Components"

'Relations
PositionComponent -|> AbstractComponent
TextComponent -|> AbstractComponent
PhysicsComponent -|> AbstractComponent
CollisionComponent -|> AbstractComponent
SpriteComponent -|> AbstractComponent
''
'' SYSTEMS
''

package "Systems" #6B7EA8 {

abstract class AbstractSystem {
   - Enum SystemType type
   ==
   + Enum SystemType getType()
   + virtual createMessages()
   + virtual generateJobs()
   + virtual process()
}

class GraphicsSystem {

}

GraphicsSystem --|> AbstractSystem

class PhysicsSystem {

}

PhysicsSystem --|> AbstractSystem

class CollisionSystem {

}

CollisionSystem --|> AbstractSystem

} 
'END package "Systems"

Kampf o-- AbstractRenderWindow
Kampf o-- AbstractSystem
Kampf o-- AbstractManager
EntityManager *-- AbstractEntity

AbstractEntity o-- AbstractComponent : many >

class Messenger {
   - list<Message> MessageQueue
==
   + Messenger()
   + appendMessage(Message message)
   + list<Message> retrieveMessages(Message message)
   + void insertMessage(int position, Message message)
   + Message popMessage()
   + Message deleteMessage(int messageID)
   + Message hasMessage(int messageID)
}

class Message {
   - int messageID
   - 
}

Messenger o-- Message

class JobScheduler {
   - Queue<Job> JobQueue
   - list<WorkerThread> workers
==
   + createWorker()
   + pushJob(Job job)
   + processQueue()
   + syncWorkers()
   + 
}

class Job {
   - std::function func
   - *void parameters
}

JobScheduler o-- Job

@enduml